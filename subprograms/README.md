# Modularity and Abstraction Activity

## ðŸ“š Overview
This repository contains our groupâ€™s submission for the Modularity and Abstraction Activity. The **objective** was:
> "To implement and evaluate modularity and abstraction using subprograms across languages."

We implemented and explored the following concepts in **[Language 1, e.g., Python]** and **[Language 2, e.g., C++]**:

- **Subprograms (Functions)**: Implemented at least two, such as Factorial and Prime Checking.
- **Modularity**: Organizing code into separate modules/files.
- **Abstraction**: Hiding implementation details via function interfaces.

Each member contributed code or a reflection to meet the activity requirements, including the mandatory **incremental Git commit** for functions.

---

## ðŸ’» Code Snippet Summary

| Concept | Python (Angela) | C++ (Adam) |
|:--------------------------|:------------------------------|:---------------------------|
| Subprogram 1: Isogram Check | âœ” | - |
| Subprogram 2: Palindrome Check | âœ” | - |
| Subprogram 3: Tautonym Check | âœ” | - |
| Subprogram 4: Calculator Ops | - | âœ” (via `Calculator.cpp`) |
| Modular Organization | âœ” (Import/Export) | âœ” (Header/Source files) |

All subprograms can be found inside the mandatory **`/subprograms/`** folder.

---

## âœ¨ Reflections

### Angela (Python)

* *Explanation of modularity and abstraction.*

Based from my understanding in this hands on activity, modularity is breaking down the program into smaller parts so it is easier to work on. Basically each module has specific part like what I did in my code. Inside the **`/modules/`** folder, I have separate .py files which are palindrome.py, isogram.py, and tautonym.py, these files have different tasks which is what modularity is all about. While on the other hand, abstraction is hiding the complicated details and only showing the important part. So for example, in my code I called the function isPalindrome(text) instead of having the whole code inside the main.py. This basically makes my code simple and less confusing.  

* *Why modular code is easier to maintain and reuse.*

Modular code is easier to maintain and reuse because each part of the program works on its own. If there is an error inside the code, I can just fix that part without breaking everything else and that it is also easier to update and change since the code is already organized. And also, I can reuse this on other projects instead of starting over.

---

### Adam (C++)

* *Explanation of modularity and abstraction.*
To what I have researched, modularity is a process of seperating complex blocks of code to a more reusable and maintanable state for the program to be used while abstraction is a technique of hiding complex codes and only features to be shown and used in the program

* *Why modular code is easier to maintain and reuse.*
  The reason is beucase complex blocks of code have become seperated and much more easier to see and understand the components of each code. In my view, this is basically dissecting the human body to see how the body ticks and what parts can we modify or add. It's like how a mad scientist created frankenstein. He simply seperated each part of the body (code) and either modify and add new parts to improve the main human body (main program)
---

### Michaela (README)

* *Explanation of modularity and abstraction.*

* *Why modular code is easier to maintain and reuse.*

---

## ðŸ‘¥ Group Members

We confirm that all functions were committed **incrementally** to showcase the development process, as required for the Git grading component.

- Angela Cabanes â€“ **Python** snippets & reflection
- Kelvin Adam Aninang â€“ **C++** snippets & reflection
- Michaela Jornales â€“ 


